/* autogenerated by Processing revision 1293 on 2024-04-23 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class projet_final_algo_h24_DominicR_MeryemB extends PApplet {

/*
**
** Travail_02
** par : Dominic & Meryem
** Présenté à Sofian Audry
** 
*/

// // librairie // //
// sound //


// // variables // //
// général //
int jardinLenght; // déclare une variable pour storer la longueur du jardin
int jardinY; // déclare une variable pour enregistrer la coordonée y du jardin
int jardinYSubDiv = 8; // sous division en y du jardin
int jardinXSubDiv = 7; // sous division en x du jardin

// couleurs //
int noir = color(49, 1, 11);
int rouge = color(239, 60, 92);
int jaune = color(234, 234, 40);
int vert = color(34, 216, 100);
int vert_foncee = color(68, 123, 28);
int bleu = color(42, 135, 223);
int bleu_pale = color(236, 248, 252);

// joueur //
// position
float pX; // déclare une variable pour la position en x du joueur
float pY; // déclare une variable pour la position en y du joueur
float pS = 5; // déclare une variable pour la vitesse de déplacement du joueur

// mouvement
boolean upKeyPressed = false;
boolean downKeyPressed = false;
boolean leftKeyPressed = false;
boolean rightKeyPressed = false;

// défilement
boolean pTop = false;
boolean pBot = false;

// objet
Joueur joueur; // déclare l'objet joueur

// plantes //
// quantité
int planteQte = 5;
int planteOffset = 100;
int offsetValue;

// position
int planteX; // déclare une variable pour la position en x de la plante
int planteY; // déclare une variable pour la position en y de la plante

// images
PImage[] plantesImage = new PImage[7]; // déclare une variable pour y storer une image

// objet
Plante[] plantes = new Plante[planteQte]; // déclare un tableau d'objet pour les plantes

// son
SoundFile backgroundSon01;

// // fonctions // //
// set up //
public void setup() {
    // général
    /* size commented out by preprocessor */; // donne la grosseur à la fenêtre

    // jardin
    jardinLenght = height * 2; // calcul la valeur pour la longueur du jardin
    jardinY = height - jardinLenght; // calcul la valeur y du jardin

    // joueur
    // // position
    pX = width/2; // donne une valeur initial à la variable pX
    pY = height/4 * 3; // donne une valeur initial à la variable pY

    // // objet
    joueur = new Joueur(pX, pY, pS); // cré un instence de l'objet joueur

    // plantes
    // // images
    for (int i = 1; i <= plantesImage.length; i++) {
        plantesImage[i - 1] = loadImage ( "img/plantes/plante-0" + i + ".png" ); // charge les images dans le tableau d'images
        plantesImage[i - 1].resize(50, 75);
    }

    // // objets
    plantes = new Plante[planteQte];

    for (int i = 0; i < planteQte; i++) {
        int planteIndex = PApplet.parseInt(random(7));
        offsetValue = PApplet.parseInt(random(planteOffset * -1, planteOffset));
        plantes[i] = new Plante(planteIndex, offsetValue);
    }
    
    // music
    // // musique de fond
    backgroundSon01 = new SoundFile(this, "sons/main_bs_02.wav"); // charge le son dans la variable
    backgroundSon01.play(); // fait jouer le son
    backgroundSon01.loop(); // fait rejouer le son une fois que ce oson a terminer de jouer
}

// draw // 
public void draw() {
    // général
    background(noir); // donne une couleur à l'arrière plan

    // joueur
    joueur.display(); // appel la méthode display de l'objet joueur
    
    // plantes
    displayGarden();
}

public void displayGarden() {
    scrolling();

    // // bande de droite
    for (int y = jardinY; y < jardinLenght; y += height/jardinYSubDiv) { // boucle en y
        for ( int x = 0; x < width/3; x += (width/3)/jardinXSubDiv) { // boucle en x
            for (int i = 0; i < planteQte; i++) { // fait apparaitre plusieurs objet en mm temps
                plantes[i].updatePosition(x, y);
                plantes[i].display(); // appel la methode display des objets plantes
            }
        }
    }

    // // bande de gauche
    for (int y = jardinY; y < jardinLenght; y += height/jardinYSubDiv) { // boucle en y
        for ( int x = width/3 * 2; x < width; x += (width/3)/jardinXSubDiv) { // boucle en x
            for (int i = 0; i < planteQte; i++) { // fait apparaitre plusieurs objet en mm temps
                plantes[i].updatePosition(x, y);
                plantes[i].display(); // appel la methode display des objets plantes
            }
        }
    }
}

public void scrolling() {
    if (jardinY >= height) {
        
    } else {
        if (pTop == true && upKeyPressed == true) {
            jardinY = jardinY + PApplet.parseInt(pS);
        }
        if (pBot == true && downKeyPressed == true) {
            jardinY = jardinY - PApplet.parseInt(pS);
        }
    }
}
class Joueur {
    // variables
    float x; // déclare une variable correspondant à la position en x de l'objet 
    float y; // déclare une variable correspondant à la position en y de l'objet
    float xSpeed; // déclare une variable correpondant à la vitesse en x de l'objet
    float ySpeed; // déclare une variable correspondant à la vitesse en y de l'objet

    // constructor
    Joueur(float x, float y, float s) {
        // variables
        this.x = x; // correspond la valeur en x qu'on donne en appelant l'objet à celle de l'instence de l'objet
        this.y = y; // correspond la valeur en y qu'on donne en appelant l'objet à celle de l'instence de l'objet
        this.xSpeed = s; // donne la valeur de vitesse s qu'on donne en appelant l'objet à celle de l'instence de l'objet
        this.ySpeed = s; // donne la valeur de vitesse s qu'on donne en appelant l'objet à celle de l'instence de l'objet
    }

    // méthodes
    // // display
    public void display() { // sert à déssiner le joueur
        // appel la méthode move
        this.move();
        
        // dessine le joueur
        fill(255);
        noStroke();
        circle(x, y, 20);
    }

    public void move() { //sert à faire bouger le joueur

        // fait bouger le joueur
        if (keyPressed == true) {
            if (key == CODED) {
                if (keyCode == UP) { // fait bouger le joueur par en haut
                    if (y > height/5) {
                        y = y - ySpeed;
                    }
                    upKeyPressed = true;
                }
                if (keyCode == DOWN) { // fait bouger le joueur par en bas
                    if (y < height/5 * 4) {
                        y = y + ySpeed;
                    }
                    downKeyPressed = true;
                }
                if (keyCode == LEFT) { // fait bouger le joueur à gauche 
                    if (x > width/3) {
                        x = x - xSpeed;
                    }
                    leftKeyPressed = true;
                }
                if (keyCode == RIGHT) { // fait bouger le joueur à droite
                    if (x < width/3 * 2) {
                        x = x + xSpeed;
                    }
                    rightKeyPressed = true;
                }
            } 
        } else {
            upKeyPressed = false;
            downKeyPressed = false;
            leftKeyPressed = false;
            rightKeyPressed = false;
        }

        // intéragit avec le défilement
        if (y <= height/5) {
            pTop = true;
        } else {
            pTop = false;
        }

        if (y >= height/5 * 4) {
            pBot = true;
        } else {
            pBot = false;
        }
    }

    public void interact() {
        /*
        ** si le joueur est proche dune technologie. un signal visuel et sonore? apparait
        ** calcul la disstance entre le joueur et les technologie
        ** sous une certaine distance le signal apparait
        */
    }
}
class Plante {
    int posX;
    int posY;
    int planteIndex;
    int offset;
    


    Plante(int planteI, int offsetValue) {
        this.planteIndex = planteI;
        this.offset = offsetValue;
    }

    public void display() {
        image(plantesImage[planteIndex], posX, posY);
    }

    public int posOffset(int a) {    
        a = a + offset;
        return a;
    }

    public void updatePosition(int x, int y) {
        posX = posOffset(x);
        posY = posOffset(y);
    }
}


class UI {

    // constructor
    UI() {

    }

    public void display() {

    }

    public void move() {

    }

    public void interact() {
        
    }
}


  public void settings() { size(1000, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "projet_final_algo_h24_DominicR_MeryemB" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
